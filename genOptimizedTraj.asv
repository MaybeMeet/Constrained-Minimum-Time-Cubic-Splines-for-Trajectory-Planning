function s = genOptimizedTraj(ndof, num_points, q, qdot_b, qdot_max, dyn_params_M, dyn_params_B, dyn_params_C, dyn_params_V)

%% Dimension check
assert(...
	isequal(size(q), [num_points, ndof]), ...
    'The trajectory points must be of size (n x ndof)' ...
)
assert(...
    isequal(size(qdot_b), [2, ndof]), ...
    'The boundary velocities must be of size (2 x n)' ...
)
assert(...
	isequal(size(qdot_max), [ndof, 1]), ...
    'The velocity constraints must be of size (ndof x 1)' ...
)
assert(...
    isequal(size(dyn_params_M), [num_points, 1]), ... 
    'There must be a total of n x 1 inertia matrices M' ...
)
assert(...
    isequal(size(dyn_params_B), [num_points, 1]), ... 
    'There must be a total of n x 1 centrifugal force matrices B' ...
)
assert(...
    isequal(size(dyn_params_V), [num_points, 1]), ... 
    'There must be a total of n x 1 centrifugal force matrices V' ...
)

assert(...
    isequal(size(dyn_params_M(1)), [ndof, ndof]), ... 
    'Each inertia matrix M must be of size (ndof x ndof) with total n x 1 matrices' ...
)



%% Setting up the spline
init_time = (1:num_points)'                     % Initial time vector
h0 = diff(init_time);                    % Knots vector 
w = max(abs(q(2:end,:) - q(1:end-1,:))./(repmat(qdot_max, [length(q)-1 1])))';

%% Setting up the spline knots optimization
options = optimoptions(@fmincon,'Algorithm','sqp');
[h,fval] = fmincon(@objfun, h0, [], [], [], [], w, h0,... 
   @(h)confuneqMultipleQs(h, ndof, q, qdot_b, qdot_max), options);

%% Resulting spline based on the optimized knots with given constraints.
new_time = zeros(length(h)+1, 1); % New knot vector
new_time (1) = 0;
for i=2:length(h)+1
    new_time(i) = new_time (i-1) + h(i-1);
end
for m=1:ndof
	[s0, s1, s2, s3] = cubic_spline(h, q(:,m), qdot_b(:,m)); % Generating spline constants
    figure
    plot(new_time, q(:,m), 'o');
    hold on
    plot_cubic_spline(new_time, s0, s1, s2, s3);
end

s = 0;
